package main

// Based loosely on example from
// https://golang.org/pkg/crypto/x509/#example_Certificate_Verify

import (
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"io/ioutil"
	"net/http"
)

func main() {
	// Which CAs do we trust?
	var trustedRootCAs = []string{
		"https://vault.lmhd.me/v1/pki/root/ca",
	}

	// Get root cert from our trusted CA list
	roots := x509.NewCertPool()
	for _, caURL := range trustedRootCAs {
		root, err := GetCAFromURL(caURL)
		if err != nil {
			panic("failed to parse inter certificate: " + err.Error())
		}
		roots.AddCert(root)
	}

	// Get certificate from a file
	// In a real example, this would come from an HTTP Header
	cert, err := GetCertFromFile("cert.pem")
	if err != nil {
		panic("failed to parse certificate: " + err.Error())
	}

	// Get Intermediary cert from main cert
	//
	// This works on the assumption of a chain like:
	//   Root --> Inter --> Cert
	//
	// If there are any further intermediaries in the chain, this will not work
	//
	// We could also require the client present its Issuing CA as an HTTP header
	// but that is out-of-scope of this proof-of-concept
	inters := x509.NewCertPool()
	for _, caURL := range cert.IssuingCertificateURL {
		inter, err := GetCAFromURL(caURL)
		if err != nil {
			panic("failed to parse inter certificate: " + err.Error())
		}
		inters.AddCert(inter)
	}

	opts := x509.VerifyOptions{
		// Our trusted CA
		Roots: roots,

		// The issuing CA, as reported by the cert
		Intermediates: inters,

		// Validate this is a client certificate
		KeyUsages: []x509.ExtKeyUsage{
			x509.ExtKeyUsageClientAuth,
		},
	}

	if _, err := cert.Verify(opts); err != nil {
		panic("failed to verify certificate: " + err.Error())
	}

	// We trust that the certificate is valid
	// (Authentication)
	fmt.Printf("Cert Generated By Trusted CA: %v\n", cert.Issuer)

	// But does it provide the required authorization?
	fmt.Printf("Cert Properties:\n\tOU: %v\n\tO:  %v\n", cert.Subject.Organization, cert.Subject.OrganizationalUnit)

	// What we do with these OUs and Os is out-of-scope of this proof-of-concept
}

// GetCertFromFile reads a certificate from a file
func GetCertFromFile(filename string) (*x509.Certificate, error) {

	certRaw, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	block, _ := pem.Decode(certRaw)
	if block == nil {
		return nil, err
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil, err
	}

	return cert, nil
}

// GetCAFromURL reads a raw Certificate Authority Certificate from a URL and
// returns it as an *x509.Certificate
func GetCAFromURL(address string) (*x509.Certificate, error) {

	resp, err := http.Get(address)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	cert, err := x509.ParseCertificate(body)
	if err != nil {
		return nil, err
	}

	return cert, nil
}
